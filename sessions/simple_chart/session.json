{"name":"simple_chart","state":"assembled","iteration":0,"prompt_count":6,"response_count":5,"classes":[{"name":"SIMPLE_CHART","description":"Main facade for charting. Loads CSV data and renders charts.","is_generated":true,"code":"note\n\tdescription: \"Main facade for charting. Loads CSV data and renders charts.\"\n\tauthor: \"Generated by simple_codegen\"\n\tdate: \"2026-01-16\"\n\nclass\n\tSIMPLE_CHART\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Create chart facade.\n\t\tdo\n\t\t\tcreate data_loader.make\n\t\t\tcreate bar_renderer.make\n\t\t\tcreate table_renderer.make\n\t\tensure\n\t\t\tdata_loader_created: data_loader /= Void\n\t\t\tbar_renderer_created: bar_renderer /= Void\n\t\t\ttable_renderer_created: table_renderer /= Void\n\t\tend\n\nfeature -- Access\n\n\tdata_loader: CSV_DATA_LOADER\n\t\t\t-- CSV data loader.\n\n\tbar_renderer: BAR_CHART_RENDERER\n\t\t\t-- Bar chart renderer.\n\n\ttable_renderer: TABLE_RENDERER\n\t\t\t-- Table renderer.\n\nfeature -- Status report\n\n\thas_data: BOOLEAN\n\t\t\t-- Is data loaded?\n\t\tdo\n\t\t\tResult := data_loader.has_data\n\t\tend\n\n\tlast_error: detachable STRING\n\t\t\t-- Last error message if any.\n\nfeature -- Element change\n\n\tload_csv (a_path: READABLE_STRING_GENERAL)\n\t\t\t-- Load CSV data from file at `a_path`.\n\t\trequire\n\t\t\tpath_not_empty: not a_path.is_empty\n\t\tdo\n\t\t\tlast_error := Void\n\t\t\tdata_loader.load_from_file (a_path)\n\t\t\tif not data_loader.has_data then\n\t\t\t\tlast_error := \"Failed to load CSV from file: \" + a_path.to_string_8\n\t\t\tend\n\t\tensure\n\t\t\tdata_loaded_or_error: has_data or last_error /= Void\n\t\tend\n\n\tload_csv_string (a_content: READABLE_STRING_GENERAL)\n\t\t\t-- Load CSV data from string `a_content`.\n\t\trequire\n\t\t\tcontent_not_empty: not a_content.is_empty\n\t\tdo\n\t\t\tlast_error := Void\n\t\t\tdata_loader.load_from_string (a_content)\n\t\t\tif not data_loader.has_data then\n\t\t\t\tlast_error := \"Failed to parse CSV content\"\n\t\t\tend\n\t\tensure\n\t\t\tdata_loaded_or_error: has_data or last_error /= Void\n\t\tend\n\nfeature -- Output\n\n\trender_bar_chart (a_label_column, a_value_column: INTEGER): STRING\n\t\t\t-- Render bar chart using columns for labels and values.\n\t\trequire\n\t\t\thas_data: has_data\n\t\t\tlabel_column_valid: a_label_column >= 1 and a_label_column <= data_loader.column_count\n\t\t\tvalue_column_valid: a_value_column >= 1 and a_value_column <= data_loader.column_count\n\t\tlocal\n\t\t\tl_labels: ARRAYED_LIST [STRING]\n\t\t\tl_values: ARRAYED_LIST [REAL_64]\n\t\tdo\n\t\t\tl_labels := data_loader.column_values (a_label_column)\n\t\t\tl_values := data_loader.column_as_numbers (a_value_column)\n\t\t\tbar_renderer.render (l_labels, l_values)\n\t\t\tResult := bar_renderer.as_string\n\t\tensure\n\t\t\tresult_not_empty: not Result.is_empty\n\t\tend\n\n\trender_table: STRING\n\t\t\t-- Render data as formatted ASCII table.\n\t\trequire\n\t\t\thas_data: has_data\n\t\tlocal\n\t\t\tl_headers: ARRAYED_LIST [STRING]\n\t\t\tl_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]]\n\t\tdo\n\t\t\tl_headers := data_loader.headers\n\t\t\tl_rows := data_loader.all_rows\n\t\t\ttable_renderer.render (l_headers, l_rows)\n\t\t\tResult := table_renderer.as_string\n\t\tensure\n\t\t\tresult_not_empty: not Result.is_empty\n\t\tend\n\nend"},{"name":"CSV_DATA_LOADER","description":"Loads CSV using SIMPLE_CSV. Provides row/column access.","is_generated":true,"code":"note\n\tdescription: \"Loads CSV using SIMPLE_CSV. Provides row/column access.\"\n\tauthor: \"Generated by simple_codegen\"\n\tdate: \"2026-01-16\"\n\nclass\n\tCSV_DATA_LOADER\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Create data loader.\n\t\tdo\n\t\t\tcreate csv_parser.make\n\t\t\tcreate cached_headers.make (0)\n\t\tensure\n\t\t\tparser_created: csv_parser /= Void\n\t\t\tno_data: not has_data\n\t\tend\n\nfeature -- Access\n\n\trow_count: INTEGER\n\t\t\t-- Number of data rows (excluding header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\tdo\n\t\t\tResult := csv_parser.row_count - 1\n\t\t\tif Result < 0 then\n\t\t\t\tResult := 0\n\t\t\tend\n\t\tensure\n\t\t\tnon_negative: Result >= 0\n\t\tend\n\n\tcolumn_count: INTEGER\n\t\t\t-- Number of columns.\n\t\trequire\n\t\t\thas_data: has_data\n\t\tdo\n\t\t\tif csv_parser.row_count > 0 then\n\t\t\t\tResult := csv_parser.row_at (1).count\n\t\t\tend\n\t\tensure\n\t\t\tnon_negative: Result >= 0\n\t\tend\n\n\theaders: ARRAYED_LIST [STRING]\n\t\t\t-- Column headers (first row of CSV).\n\t\trequire\n\t\t\thas_data: has_data\n\t\tdo\n\t\t\tResult := cached_headers.twin\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\n\tall_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]]\n\t\t\t-- All data rows (excluding header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\tlocal\n\t\t\ti: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (row_count)\n\t\t\tfrom\n\t\t\t\ti := 2\n\t\t\tuntil\n\t\t\t\ti > csv_parser.row_count\n\t\t\tloop\n\t\t\t\tResult.extend (csv_parser.row_at (i))\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\t\tcorrect_count: Result.count = row_count\n\t\tend\n\n\tcolumn_values (a_column: INTEGER): ARRAYED_LIST [STRING]\n\t\t\t-- Values from column `a_column` (1-based, excludes header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\t\tcolumn_valid: a_column >= 1 and a_column <= column_count\n\t\tlocal\n\t\t\ti: INTEGER\n\t\t\tl_row: ARRAYED_LIST [STRING]\n\t\tdo\n\t\t\tcreate Result.make (row_count)\n\t\t\tfrom\n\t\t\t\ti := 2\n\t\t\tuntil\n\t\t\t\ti > csv_parser.row_count\n\t\t\tloop\n\t\t\t\tl_row := csv_parser.row_at (i)\n\t\t\t\tif a_column <= l_row.count then\n\t\t\t\t\tResult.extend (l_row.i_th (a_column))\n\t\t\t\telse\n\t\t\t\t\tResult.extend (\"\")\n\t\t\t\tend\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\t\tcorrect_count: Result.count = row_count\n\t\tend\n\n\tcolumn_as_numbers (a_column: INTEGER): ARRAYED_LIST [REAL_64]\n\t\t\t-- Numeric values from column `a_column` (1-based, excludes header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\t\tcolumn_valid: a_column >= 1 and a_column <= column_count\n\t\tlocal\n\t\t\tl_values: ARRAYED_LIST [STRING]\n\t\t\tl_val: REAL_64\n\t\tdo\n\t\t\tl_values := column_values (a_column)\n\t\t\tcreate Result.make (l_values.count)\n\t\t\tacross l_values as ic loop\n\t\t\t\tif ic.is_double then\n\t\t\t\t\tl_val := ic.to_double\n\t\t\t\telse\n\t\t\t\t\tl_val := 0.0\n\t\t\t\tend\n\t\t\t\tResult.extend (l_val)\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\t\tcorrect_count: Result.count = row_count\n\t\tend\n\nfeature -- Status report\n\n\thas_data: BOOLEAN\n\t\t\t-- Has data been loaded?\n\t\tdo\n\t\t\tResult := csv_parser.row_count > 0\n\t\tend\n\nfeature -- Element change\n\n\tload_from_file (a_path: READABLE_STRING_GENERAL)\n\t\t\t-- Load CSV data from file at `a_path`.\n\t\trequire\n\t\t\tpath_not_empty: not a_path.is_empty\n\t\tlocal\n\t\t\tl_file: SIMPLE_FILE\n\t\t\tl_content: STRING\n\t\tdo\n\t\t\tcreate l_file.make (a_path)\n\t\t\tif l_file.exists then\n\t\t\t\tl_content := l_file.read_all\n\t\t\t\tload_from_string (l_content)\n\t\t\tend\n\t\tend\n\n\tload_from_string (a_content: READABLE_STRING_GENERAL)\n\t\t\t-- Load CSV data from string `a_content`.\n\t\trequire\n\t\t\tcontent_not_empty: not a_content.is_empty\n\t\tdo\n\t\t\tcsv_parser.parse (a_content.to_string_8)\n\t\t\tcache_headers\n\t\tensure\n\t\t\thas_data_if_valid: csv_parser.row_count > 0 implies has_data\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tcsv_parser: SIMPLE_CSV\n\t\t\t-- CSV parser.\n\n\tcached_headers: ARRAYED_LIST [STRING]\n\t\t\t-- Cached headers from first row.\n\n\tcache_headers\n\t\t\t-- Cache headers from first row.\n\t\tlocal\n\t\t\tl_row: ARRAYED_LIST [STRING]\n\t\tdo\n\t\t\tcached_headers.wipe_out\n\t\t\tif csv_parser.row_count > 0 then\n\t\t\t\tl_row := csv_parser.row_at (1)\n\t\t\t\tacross l_row as ic loop\n\t\t\t\t\tcached_headers.extend (ic)\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\theaders_cached: csv_parser.row_count > 0 implies cached_headers.count > 0\n\t\tend\n\nend"},{"name":"BAR_CHART_RENDERER","description":"Renders horizontal ASCII bar charts.","is_generated":true,"code":"note\n\tdescription: \"Renders horizontal ASCII bar charts.\"\n\tauthor: \"Generated by simple_codegen\"\n\tdate: \"2026-01-16\"\n\nclass\n\tBAR_CHART_RENDERER\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Create bar chart renderer.\n\t\tdo\n\t\t\tcreate output.make_empty\n\t\t\tbar_width := Default_bar_width\n\t\t\tbar_character := '#'\n\t\tensure\n\t\t\toutput_empty: output.is_empty\n\t\t\tdefault_width: bar_width = Default_bar_width\n\t\tend\n\nfeature -- Access\n\n\toutput: STRING\n\t\t\t-- Rendered output.\n\n\tas_string: STRING\n\t\t\t-- Get rendered chart as string.\n\t\tdo\n\t\t\tResult := output.twin\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\nfeature -- Settings\n\n\tbar_width: INTEGER\n\t\t\t-- Maximum width of bars in characters.\n\n\tbar_character: CHARACTER\n\t\t\t-- Character used for bar fill.\n\n\tset_bar_width (a_width: INTEGER)\n\t\t\t-- Set maximum bar width.\n\t\trequire\n\t\t\twidth_positive: a_width > 0\n\t\tdo\n\t\t\tbar_width := a_width\n\t\tensure\n\t\t\twidth_set: bar_width = a_width\n\t\tend\n\n\tset_bar_character (a_char: CHARACTER)\n\t\t\t-- Set bar fill character.\n\t\tdo\n\t\t\tbar_character := a_char\n\t\tensure\n\t\t\tcharacter_set: bar_character = a_char\n\t\tend\n\nfeature -- Status report\n\n\tis_rendered: BOOLEAN\n\t\t\t-- Has a chart been rendered?\n\t\tdo\n\t\t\tResult := not output.is_empty\n\t\tend\n\nfeature -- Element change\n\n\trender (a_labels: ARRAYED_LIST [STRING]; a_values: ARRAYED_LIST [REAL_64])\n\t\t\t-- Render bar chart from labels and values.\n\t\trequire\n\t\t\tlabels_attached: a_labels /= Void\n\t\t\tvalues_attached: a_values /= Void\n\t\t\tsame_count: a_labels.count = a_values.count\n\t\tlocal\n\t\t\tl_max_value: REAL_64\n\t\t\tl_max_label_width: INTEGER\n\t\t\tl_bar_length: INTEGER\n\t\t\tl_label: STRING\n\t\t\tl_value: REAL_64\n\t\t\ti: INTEGER\n\t\tdo\n\t\t\toutput.wipe_out\n\t\t\t\n\t\t\tif a_labels.is_empty then\n\t\t\t\t-- Nothing to render\n\t\t\telse\n\t\t\t\t-- Find maximum value for scaling\n\t\t\t\tl_max_value := 0.0\n\t\t\t\tacross a_values as ic loop\n\t\t\t\t\tif ic > l_max_value then\n\t\t\t\t\t\tl_max_value := ic\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\t-- Find maximum label width for alignment\n\t\t\t\tl_max_label_width := 0\n\t\t\t\tacross a_labels as ic loop\n\t\t\t\t\tif ic.count > l_max_label_width then\n\t\t\t\t\t\tl_max_label_width := ic.count\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\t-- Render each bar\n\t\t\t\tfrom\n\t\t\t\t\ti := 1\n\t\t\t\tuntil\n\t\t\t\t\ti > a_labels.count\n\t\t\t\tloop\n\t\t\t\t\tl_label := a_labels.i_th (i)\n\t\t\t\t\tl_value := a_values.i_th (i)\n\t\t\t\t\t\n\t\t\t\t\t-- Pad label to align bars\n\t\t\t\t\toutput.append (padded_label (l_label, l_max_label_width))\n\t\t\t\t\toutput.append (\" | \")\n\t\t\t\t\t\n\t\t\t\t\t-- Calculate bar length\n\t\t\t\t\tif l_max_value > 0.0 then\n\t\t\t\t\t\tl_bar_length := (l_value / l_max_value * bar_width).truncated_to_integer\n\t\t\t\t\telse\n\t\t\t\t\t\tl_bar_length := 0\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\t-- Render bar\n\t\t\t\t\toutput.append (bar_string (l_bar_length))\n\t\t\t\t\toutput.append (\" \")\n\t\t\t\t\toutput.append (l_value.out)\n\t\t\t\t\toutput.append_character ('%N')\n\t\t\t\t\t\n\t\t\t\t\ti := i + 1\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\trendered_if_data: not a_labels.is_empty implies is_rendered\n\t\tend\n\nfeature -- Constants\n\n\tDefault_bar_width: INTEGER = 40\n\t\t\t-- Default maximum bar width.\n\nfeature {NONE} -- Implementation\n\n\tpadded_label (a_label: STRING; a_width: INTEGER): STRING\n\t\t\t-- Label padded to `a_width` characters.\n\t\trequire\n\t\t\tlabel_attached: a_label /= Void\n\t\t\twidth_valid: a_width >= a_label.count\n\t\tlocal\n\t\t\tl_padding: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (a_width)\n\t\t\tResult.append (a_label)\n\t\t\tl_padding := a_width - a_label.count\n\t\t\tfrom until l_padding = 0 loop\n\t\t\t\tResult.append_character (' ')\n\t\t\t\tl_padding := l_padding - 1\n\t\t\tend\n\t\tensure\n\t\t\tcorrect_length: Result.count = a_width\n\t\tend\n\n\tbar_string (a_length: INTEGER): STRING\n\t\t\t-- String of bar characters with given length.\n\t\trequire\n\t\t\tlength_non_negative: a_length >= 0\n\t\tlocal\n\t\t\ti: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (a_length)\n\t\t\tfrom\n\t\t\t\ti := 1\n\t\t\tuntil\n\t\t\t\ti > a_length\n\t\t\tloop\n\t\t\t\tResult.append_character (bar_character)\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\tensure\n\t\t\tcorrect_length: Result.count = a_length\n\t\tend\n\nend"},{"name":"TABLE_RENDERER","description":"Renders formatted ASCII tables.","is_generated":true,"code":"note\n\tdescription: \"Renders formatted ASCII tables.\"\n\tauthor: \"Generated by simple_codegen\"\n\tdate: \"2026-01-16\"\n\nclass\n\tTABLE_RENDERER\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Create table renderer.\n\t\tdo\n\t\t\tcreate output.make_empty\n\t\t\tcreate column_widths.make (0)\n\t\tensure\n\t\t\toutput_empty: output.is_empty\n\t\tend\n\nfeature -- Access\n\n\toutput: STRING\n\t\t\t-- Rendered output.\n\n\tas_string: STRING\n\t\t\t-- Get rendered table as string.\n\t\tdo\n\t\t\tResult := output.twin\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\nfeature -- Status report\n\n\tis_rendered: BOOLEAN\n\t\t\t-- Has a table been rendered?\n\t\tdo\n\t\t\tResult := not output.is_empty\n\t\tend\n\nfeature -- Element change\n\n\trender (a_headers: ARRAYED_LIST [STRING]; a_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]])\n\t\t\t-- Render table from headers and rows.\n\t\trequire\n\t\t\theaders_attached: a_headers /= Void\n\t\t\trows_attached: a_rows /= Void\n\t\tdo\n\t\t\toutput.wipe_out\n\t\t\tcalculate_column_widths (a_headers, a_rows)\n\t\t\t\n\t\t\t-- Render header\n\t\t\trender_separator\n\t\t\trender_row (a_headers)\n\t\t\trender_separator\n\t\t\t\n\t\t\t-- Render data rows\n\t\t\tacross a_rows as ic loop\n\t\t\t\trender_row (ic)\n\t\t\tend\n\t\t\t\n\t\t\t-- Render bottom border\n\t\t\tif not a_rows.is_empty then\n\t\t\t\trender_separator\n\t\t\tend\n\t\tensure\n\t\t\trendered_if_headers: not a_headers.is_empty implies is_rendered\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tcolumn_widths: ARRAYED_LIST [INTEGER]\n\t\t\t-- Width of each column.\n\n\tcalculate_column_widths (a_headers: ARRAYED_LIST [STRING]; a_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]])\n\t\t\t-- Calculate column widths based on content.\n\t\trequire\n\t\t\theaders_attached: a_headers /= Void\n\t\t\trows_attached: a_rows /= Void\n\t\tlocal\n\t\t\tl_col: INTEGER\n\t\t\tl_width: INTEGER\n\t\t\tl_cell: STRING\n\t\tdo\n\t\t\tcolumn_widths.wipe_out\n\t\t\t\n\t\t\t-- Start with header widths\n\t\t\tacross a_headers as ic loop\n\t\t\t\tcolumn_widths.extend (ic.count)\n\t\t\tend\n\t\t\t\n\t\t\t-- Update with row content widths\n\t\t\tacross a_rows as row_ic loop\n\t\t\t\tfrom\n\t\t\t\t\tl_col := 1\n\t\t\t\tuntil\n\t\t\t\t\tl_col > row_ic.count\n\t\t\t\tloop\n\t\t\t\t\tl_cell := row_ic.i_th (l_col)\n\t\t\t\t\tl_width := l_cell.count\n\t\t\t\t\t\n\t\t\t\t\tif l_col <= column_widths.count then\n\t\t\t\t\t\tif l_width > column_widths.i_th (l_col) then\n\t\t\t\t\t\t\tcolumn_widths.put_i_th (l_width, l_col)\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tcolumn_widths.extend (l_width)\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tl_col := l_col + 1\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\tcolumns_calculated: column_widths.count >= a_headers.count\n\t\tend\n\n\trender_separator\n\t\t\t-- Render horizontal separator line.\n\t\tlocal\n\t\t\tl_first: BOOLEAN\n\t\tdo\n\t\t\toutput.append_character ('+')\n\t\t\tl_first := True\n\t\t\tacross column_widths as ic loop\n\t\t\t\tif not l_first then\n\t\t\t\t\toutput.append_character ('+')\n\t\t\t\tend\n\t\t\t\toutput.append (repeat_char ('-', ic + 2))\n\t\t\t\tl_first := False\n\t\t\tend\n\t\t\toutput.append_character ('+')\n\t\t\toutput.append_character ('%N')\n\t\tend\n\n\trender_row (a_cells: ARRAYED_LIST [STRING])\n\t\t\t-- Render a single row.\n\t\trequire\n\t\t\tcells_attached: a_cells /= Void\n\t\tlocal\n\t\t\tl_col: INTEGER\n\t\t\tl_cell: STRING\n\t\t\tl_width: INTEGER\n\t\tdo\n\t\t\toutput.append_character ('|')\n\t\t\tfrom\n\t\t\t\tl_col := 1\n\t\t\tuntil\n\t\t\t\tl_col > column_widths.count\n\t\t\tloop\n\t\t\t\tif l_col <= a_cells.count then\n\t\t\t\t\tl_cell := a_cells.i_th (l_col)\n\t\t\t\telse\n\t\t\t\t\tl_cell := \"\"\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tl_width := column_widths.i_th (l_col)\n\t\t\t\toutput.append_character (' ')\n\t\t\t\toutput.append (padded_cell (l_cell, l_width))\n\t\t\t\toutput.append_character (' ')\n\t\t\t\toutput.append_character ('|')\n\t\t\t\t\n\t\t\t\tl_col := l_col + 1\n\t\t\tend\n\t\t\toutput.append_character ('%N')\n\t\tend\n\n\tpadded_cell (a_content: STRING; a_width: INTEGER): STRING\n\t\t\t-- Cell content padded to width.\n\t\trequire\n\t\t\tcontent_attached: a_content /= Void\n\t\t\twidth_non_negative: a_width >= 0\n\t\tlocal\n\t\t\tl_padding: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (a_width)\n\t\t\tResult.append (a_content)\n\t\t\tl_padding := a_width - a_content.count\n\t\t\tfrom until l_padding <= 0 loop\n\t\t\t\tResult.append_character (' ')\n\t\t\t\tl_padding := l_padding - 1\n\t\t\tend\n\t\tensure\n\t\t\tcorrect_min_length: Result.count >= a_width\n\t\tend\n\n\trepeat_char (a_char: CHARACTER; a_count: INTEGER): STRING\n\t\t\t-- String with character repeated.\n\t\trequire\n\t\t\tcount_non_negative: a_count >= 0\n\t\tlocal\n\t\t\ti: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (a_count)\n\t\t\tfrom\n\t\t\t\ti := 1\n\t\t\tuntil\n\t\t\t\ti > a_count\n\t\t\tloop\n\t\t\t\tResult.append_character (a_char)\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\tensure\n\t\t\tcorrect_length: Result.count = a_count\n\t\tend\n\nend"}]}