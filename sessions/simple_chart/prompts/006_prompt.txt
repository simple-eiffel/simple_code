Generate comprehensive tests for the Eiffel class: SIMPLE_CHART

=== CLASS UNDER TEST ===
note
	description: "Main facade for charting. Loads CSV data and renders charts."
	author: "Generated by simple_codegen"
	date: "2026-01-16"

class
	SIMPLE_CHART

create
	make

feature {NONE} -- Initialization

	make
			-- Create chart facade.
		do
			create data_loader.make
			create bar_renderer.make
			create table_renderer.make
		ensure
			data_loader_created: data_loader /= Void
			bar_renderer_created: bar_renderer /= Void
			table_renderer_created: table_renderer /= Void
		end

feature -- Access

	data_loader: CSV_DATA_LOADER
			-- CSV data loader.

	bar_renderer: BAR_CHART_RENDERER
			-- Bar chart renderer.

	table_renderer: TABLE_RENDERER
			-- Table renderer.

feature -- Status report

	has_data: BOOLEAN
			-- Is data loaded?
		do
			Result := data_loader.has_data
		end

	last_error: detachable STRING
			-- Last error message if any.

feature -- Element change

	load_csv (a_path: READABLE_STRING_GENERAL)
			-- Load CSV data from file at `a_path`.
		require
			path_not_empty: not a_path.is_empty
		do
			last_error := Void
			data_loader.load_from_file (a_path)
			if not data_loader.has_data then
				last_error := "Failed to load CSV from file: " + a_path.to_string_8
			end
		ensure
			data_loaded_or_error: has_data or last_error /= Void
		end

	load_csv_string (a_content: READABLE_STRING_GENERAL)
			-- Load CSV data from string `a_content`.
		require
			content_not_empty: not a_content.is_empty
		do
			last_error := Void
			data_loader.load_from_string (a_content)
			if not data_loader.has_data then
				last_error := "Failed to parse CSV content"
			end
		ensure
			data_loaded_or_error: has_data or last_error /= Void
		end

feature -- Output

	render_bar_chart (a_label_column, a_value_column: INTEGER): STRING
			-- Render bar chart using columns for labels and values.
		require
			has_data: has_data
			label_column_valid: a_label_column >= 1 and a_label_column <= data_loader.column_count
			value_column_valid: a_value_column >= 1 and a_value_column <= data_loader.column_count
		local
			l_labels: ARRAYED_LIST [STRING]
			l_values: ARRAYED_LIST [REAL_64]
		do
			l_labels := data_loader.column_values (a_label_column)
			l_values := data_loader.column_as_numbers (a_value_column)
			bar_renderer.render (l_labels, l_values)
			Result := bar_renderer.as_string
		ensure
			result_not_empty: not Result.is_empty
		end

	render_table: STRING
			-- Render data as formatted ASCII table.
		require
			has_data: has_data
		local
			l_headers: ARRAYED_LIST [STRING]
			l_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]]
		do
			l_headers := data_loader.headers
			l_rows := data_loader.all_rows
			table_renderer.render (l_headers, l_rows)
			Result := table_renderer.as_string
		ensure
			result_not_empty: not Result.is_empty
		end

end

=== TEST GENERATION GUIDELINES ===

Generate comprehensive tests using Eiffel's Testing framework.
Test class should inherit from EQA_TEST_SET.

1. HAPPY PATH TESTS:
   - Test normal operation with valid inputs
   - Verify postconditions are satisfied
   - Check state changes after commands
   - Test typical use case scenarios

2. EDGE CASE TESTS (Critical):
   - Boundary values (empty strings, zero, max values)
   - Precondition boundaries (just valid, just invalid)
   - State transitions at limits
   - Concurrent-like scenarios if applicable

3. CONTRACT VERIFICATION:
   - Tests that verify preconditions reject bad input
   - Tests that verify postconditions hold
   - Tests that verify invariants are maintained

4. TEST NAMING:
   - test_<feature>_<scenario> (test_add_contact_success)
   - test_<feature>_<edge_case> (test_add_contact_empty_name_rejected)

5. TEST STRUCTURE:
   feature -- Test: <Feature Group>
       test_feature_happy_path
       test_feature_edge_case_1
       test_feature_edge_case_2

=== OUTPUT FORMAT ===
Respond with a JSON object containing the test class:

```json
{
  "type": "test_class",
  "class_name": "TEST_LIBRARY_BOOK",
  "target_class": "LIBRARY_BOOK",
  "test_count": 8,
  "code": "note\n    description: \"Tests for LIBRARY_BOOK\"\nclass\n    TEST_LIBRARY_BOOK\ninherit\n    EQA_TEST_SET\n...\nend"
}
```

Output ONLY the JSON. No explanations before or after.

=== NEXT CLI COMMAND ===
Save this JSON response to a file and run:
  simple_codegen process --session <SESSION> --input <response_file.json>

Then compile and run the tests:
  simple_codegen compile --session <SESSION> --project <assembled_project>

If tests fail, refinement prompts will be auto-generated for the failing classes.
Generate tests for other classes:
  simple_codegen generate-tests --session <SESSION> --class <ANOTHER_CLASS>