{
  "type": "class_code",
  "class_name": "TABLE_RENDERER",
  "code": "note\n\tdescription: \"Renders formatted ASCII tables.\"\n\tauthor: \"Generated by simple_codegen\"\n\tdate: \"2026-01-16\"\n\nclass\n\tTABLE_RENDERER\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Create table renderer.\n\t\tdo\n\t\t\tcreate output.make_empty\n\t\t\tcreate column_widths.make (0)\n\t\tensure\n\t\t\toutput_empty: output.is_empty\n\t\tend\n\nfeature -- Access\n\n\toutput: STRING\n\t\t\t-- Rendered output.\n\n\tas_string: STRING\n\t\t\t-- Get rendered table as string.\n\t\tdo\n\t\t\tResult := output.twin\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\nfeature -- Status report\n\n\tis_rendered: BOOLEAN\n\t\t\t-- Has a table been rendered?\n\t\tdo\n\t\t\tResult := not output.is_empty\n\t\tend\n\nfeature -- Element change\n\n\trender (a_headers: ARRAYED_LIST [STRING]; a_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]])\n\t\t\t-- Render table from headers and rows.\n\t\trequire\n\t\t\theaders_attached: a_headers /= Void\n\t\t\trows_attached: a_rows /= Void\n\t\tdo\n\t\t\toutput.wipe_out\n\t\t\tcalculate_column_widths (a_headers, a_rows)\n\t\t\t\n\t\t\t-- Render header\n\t\t\trender_separator\n\t\t\trender_row (a_headers)\n\t\t\trender_separator\n\t\t\t\n\t\t\t-- Render data rows\n\t\t\tacross a_rows as ic loop\n\t\t\t\trender_row (ic)\n\t\t\tend\n\t\t\t\n\t\t\t-- Render bottom border\n\t\t\tif not a_rows.is_empty then\n\t\t\t\trender_separator\n\t\t\tend\n\t\tensure\n\t\t\trendered_if_headers: not a_headers.is_empty implies is_rendered\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tcolumn_widths: ARRAYED_LIST [INTEGER]\n\t\t\t-- Width of each column.\n\n\tcalculate_column_widths (a_headers: ARRAYED_LIST [STRING]; a_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]])\n\t\t\t-- Calculate column widths based on content.\n\t\trequire\n\t\t\theaders_attached: a_headers /= Void\n\t\t\trows_attached: a_rows /= Void\n\t\tlocal\n\t\t\tl_col: INTEGER\n\t\t\tl_width: INTEGER\n\t\t\tl_cell: STRING\n\t\tdo\n\t\t\tcolumn_widths.wipe_out\n\t\t\t\n\t\t\t-- Start with header widths\n\t\t\tacross a_headers as ic loop\n\t\t\t\tcolumn_widths.extend (ic.count)\n\t\t\tend\n\t\t\t\n\t\t\t-- Update with row content widths\n\t\t\tacross a_rows as row_ic loop\n\t\t\t\tfrom\n\t\t\t\t\tl_col := 1\n\t\t\t\tuntil\n\t\t\t\t\tl_col > row_ic.count\n\t\t\t\tloop\n\t\t\t\t\tl_cell := row_ic.i_th (l_col)\n\t\t\t\t\tl_width := l_cell.count\n\t\t\t\t\t\n\t\t\t\t\tif l_col <= column_widths.count then\n\t\t\t\t\t\tif l_width > column_widths.i_th (l_col) then\n\t\t\t\t\t\t\tcolumn_widths.put_i_th (l_width, l_col)\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tcolumn_widths.extend (l_width)\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tl_col := l_col + 1\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\tcolumns_calculated: column_widths.count >= a_headers.count\n\t\tend\n\n\trender_separator\n\t\t\t-- Render horizontal separator line.\n\t\tlocal\n\t\t\tl_first: BOOLEAN\n\t\tdo\n\t\t\toutput.append_character ('+')\n\t\t\tl_first := True\n\t\t\tacross column_widths as ic loop\n\t\t\t\tif not l_first then\n\t\t\t\t\toutput.append_character ('+')\n\t\t\t\tend\n\t\t\t\toutput.append (repeat_char ('-', ic + 2))\n\t\t\t\tl_first := False\n\t\t\tend\n\t\t\toutput.append_character ('+')\n\t\t\toutput.append_character ('%N')\n\t\tend\n\n\trender_row (a_cells: ARRAYED_LIST [STRING])\n\t\t\t-- Render a single row.\n\t\trequire\n\t\t\tcells_attached: a_cells /= Void\n\t\tlocal\n\t\t\tl_col: INTEGER\n\t\t\tl_cell: STRING\n\t\t\tl_width: INTEGER\n\t\tdo\n\t\t\toutput.append_character ('|')\n\t\t\tfrom\n\t\t\t\tl_col := 1\n\t\t\tuntil\n\t\t\t\tl_col > column_widths.count\n\t\t\tloop\n\t\t\t\tif l_col <= a_cells.count then\n\t\t\t\t\tl_cell := a_cells.i_th (l_col)\n\t\t\t\telse\n\t\t\t\t\tl_cell := \"\"\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tl_width := column_widths.i_th (l_col)\n\t\t\t\toutput.append_character (' ')\n\t\t\t\toutput.append (padded_cell (l_cell, l_width))\n\t\t\t\toutput.append_character (' ')\n\t\t\t\toutput.append_character ('|')\n\t\t\t\t\n\t\t\t\tl_col := l_col + 1\n\t\t\tend\n\t\t\toutput.append_character ('%N')\n\t\tend\n\n\tpadded_cell (a_content: STRING; a_width: INTEGER): STRING\n\t\t\t-- Cell content padded to width.\n\t\trequire\n\t\t\tcontent_attached: a_content /= Void\n\t\t\twidth_non_negative: a_width >= 0\n\t\tlocal\n\t\t\tl_padding: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (a_width)\n\t\t\tResult.append (a_content)\n\t\t\tl_padding := a_width - a_content.count\n\t\t\tfrom until l_padding <= 0 loop\n\t\t\t\tResult.append_character (' ')\n\t\t\t\tl_padding := l_padding - 1\n\t\t\tend\n\t\tensure\n\t\t\tcorrect_min_length: Result.count >= a_width\n\t\tend\n\n\trepeat_char (a_char: CHARACTER; a_count: INTEGER): STRING\n\t\t\t-- String with character repeated.\n\t\trequire\n\t\t\tcount_non_negative: a_count >= 0\n\t\tlocal\n\t\t\ti: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (a_count)\n\t\t\tfrom\n\t\t\t\ti := 1\n\t\t\tuntil\n\t\t\t\ti > a_count\n\t\t\tloop\n\t\t\t\tResult.append_character (a_char)\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\tensure\n\t\t\tcorrect_length: Result.count = a_count\n\t\tend\n\nend",
  "notes": "ASCII table renderer with box-drawing borders. Auto-calculates column widths from content. Cells left-aligned with padding."
}
