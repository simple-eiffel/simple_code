{
  "type": "class_code",
  "class_name": "CSV_DATA_LOADER",
  "code": "note\n\tdescription: \"Loads CSV using SIMPLE_CSV. Provides row/column access.\"\n\tauthor: \"Generated by simple_codegen\"\n\tdate: \"2026-01-16\"\n\nclass\n\tCSV_DATA_LOADER\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Create data loader.\n\t\tdo\n\t\t\tcreate csv_parser.make\n\t\t\tcreate cached_headers.make (0)\n\t\tensure\n\t\t\tparser_created: csv_parser /= Void\n\t\t\tno_data: not has_data\n\t\tend\n\nfeature -- Access\n\n\trow_count: INTEGER\n\t\t\t-- Number of data rows (excluding header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\tdo\n\t\t\tResult := csv_parser.row_count - 1\n\t\t\tif Result < 0 then\n\t\t\t\tResult := 0\n\t\t\tend\n\t\tensure\n\t\t\tnon_negative: Result >= 0\n\t\tend\n\n\tcolumn_count: INTEGER\n\t\t\t-- Number of columns.\n\t\trequire\n\t\t\thas_data: has_data\n\t\tdo\n\t\t\tif csv_parser.row_count > 0 then\n\t\t\t\tResult := csv_parser.row_at (1).count\n\t\t\tend\n\t\tensure\n\t\t\tnon_negative: Result >= 0\n\t\tend\n\n\theaders: ARRAYED_LIST [STRING]\n\t\t\t-- Column headers (first row of CSV).\n\t\trequire\n\t\t\thas_data: has_data\n\t\tdo\n\t\t\tResult := cached_headers.twin\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\n\tall_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]]\n\t\t\t-- All data rows (excluding header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\tlocal\n\t\t\ti: INTEGER\n\t\tdo\n\t\t\tcreate Result.make (row_count)\n\t\t\tfrom\n\t\t\t\ti := 2\n\t\t\tuntil\n\t\t\t\ti > csv_parser.row_count\n\t\t\tloop\n\t\t\t\tResult.extend (csv_parser.row_at (i))\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\t\tcorrect_count: Result.count = row_count\n\t\tend\n\n\tcolumn_values (a_column: INTEGER): ARRAYED_LIST [STRING]\n\t\t\t-- Values from column `a_column` (1-based, excludes header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\t\tcolumn_valid: a_column >= 1 and a_column <= column_count\n\t\tlocal\n\t\t\ti: INTEGER\n\t\t\tl_row: ARRAYED_LIST [STRING]\n\t\tdo\n\t\t\tcreate Result.make (row_count)\n\t\t\tfrom\n\t\t\t\ti := 2\n\t\t\tuntil\n\t\t\t\ti > csv_parser.row_count\n\t\t\tloop\n\t\t\t\tl_row := csv_parser.row_at (i)\n\t\t\t\tif a_column <= l_row.count then\n\t\t\t\t\tResult.extend (l_row.i_th (a_column))\n\t\t\t\telse\n\t\t\t\t\tResult.extend (\"\")\n\t\t\t\tend\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\t\tcorrect_count: Result.count = row_count\n\t\tend\n\n\tcolumn_as_numbers (a_column: INTEGER): ARRAYED_LIST [REAL_64]\n\t\t\t-- Numeric values from column `a_column` (1-based, excludes header).\n\t\trequire\n\t\t\thas_data: has_data\n\t\t\tcolumn_valid: a_column >= 1 and a_column <= column_count\n\t\tlocal\n\t\t\tl_values: ARRAYED_LIST [STRING]\n\t\t\tl_val: REAL_64\n\t\tdo\n\t\t\tl_values := column_values (a_column)\n\t\t\tcreate Result.make (l_values.count)\n\t\t\tacross l_values as ic loop\n\t\t\t\tif ic.is_double then\n\t\t\t\t\tl_val := ic.to_double\n\t\t\t\telse\n\t\t\t\t\tl_val := 0.0\n\t\t\t\tend\n\t\t\t\tResult.extend (l_val)\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\t\tcorrect_count: Result.count = row_count\n\t\tend\n\nfeature -- Status report\n\n\thas_data: BOOLEAN\n\t\t\t-- Has data been loaded?\n\t\tdo\n\t\t\tResult := csv_parser.row_count > 0\n\t\tend\n\nfeature -- Element change\n\n\tload_from_file (a_path: READABLE_STRING_GENERAL)\n\t\t\t-- Load CSV data from file at `a_path`.\n\t\trequire\n\t\t\tpath_not_empty: not a_path.is_empty\n\t\tlocal\n\t\t\tl_file: SIMPLE_FILE\n\t\t\tl_content: STRING\n\t\tdo\n\t\t\tcreate l_file.make (a_path)\n\t\t\tif l_file.exists then\n\t\t\t\tl_content := l_file.read_all\n\t\t\t\tload_from_string (l_content)\n\t\t\tend\n\t\tend\n\n\tload_from_string (a_content: READABLE_STRING_GENERAL)\n\t\t\t-- Load CSV data from string `a_content`.\n\t\trequire\n\t\t\tcontent_not_empty: not a_content.is_empty\n\t\tdo\n\t\t\tcsv_parser.parse (a_content.to_string_8)\n\t\t\tcache_headers\n\t\tensure\n\t\t\thas_data_if_valid: csv_parser.row_count > 0 implies has_data\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tcsv_parser: SIMPLE_CSV\n\t\t\t-- CSV parser.\n\n\tcached_headers: ARRAYED_LIST [STRING]\n\t\t\t-- Cached headers from first row.\n\n\tcache_headers\n\t\t\t-- Cache headers from first row.\n\t\tlocal\n\t\t\tl_row: ARRAYED_LIST [STRING]\n\t\tdo\n\t\t\tcached_headers.wipe_out\n\t\t\tif csv_parser.row_count > 0 then\n\t\t\t\tl_row := csv_parser.row_at (1)\n\t\t\t\tacross l_row as ic loop\n\t\t\t\t\tcached_headers.extend (ic)\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\theaders_cached: csv_parser.row_count > 0 implies cached_headers.count > 0\n\t\tend\n\nend",
  "notes": "Wraps SIMPLE_CSV for CSV loading. First row treated as headers. Uses 1-based indices. Numeric conversion handles non-numeric values as 0.0."
}