Generate comprehensive tests for the Eiffel class: SIMPLE_POSTGRES

=== CLASS UNDER TEST ===
note
	description: "[
		Simple PostgreSQL client library facade.
		
		Provides easy-to-use API for PostgreSQL database operations.
		Wraps libpq with Eiffel idioms and Design by Contract.
		
		Usage:
			create db.make
			db.connect ("host=localhost dbname=test user=postgres")
			if db.is_connected then
				db.query ("SELECT * FROM users")
				if attached db.last_result as res then
					-- process results
					res.clear
				end
				db.disconnect
			end
	]" 
	author: "Larry Rix"
	date: "$Date$"
	revision: "$Revision$"

class
	SIMPLE_POSTGRES

create
	make

feature {NONE} -- Initialization

	make
			-- Initialize disconnected database client.
		do
			create connection.make
			create last_error.make_empty
		ensure
			not_connected: not is_connected
			no_result: last_result = Void
		end

feature -- Access

	last_result: detachable PG_RESULT
			-- Result from last query operation.
			-- Void if no query executed or query failed.

	last_error: STRING
			-- Last error message (empty if no error)

	affected_rows: INTEGER
			-- Number of rows affected by last execute command

feature -- Status Report

	is_connected: BOOLEAN
			-- Is database connection open?
		do
			Result := connection.is_connected
		end

feature -- Connection Operations

	connect (a_connection_string: STRING)
			-- Connect to PostgreSQL database.
			-- Connection string format: "host=localhost port=5432 dbname=mydb user=postgres password=secret"
		require
			not_connected: not is_connected
			connection_string_valid: a_connection_string /= Void and then not a_connection_string.is_empty
		do
			last_error.wipe_out
			connection.connect (a_connection_string)
			if not connection.is_connected then
				last_error := connection.last_error.twin
			end
		ensure
			connected_or_error: is_connected or not last_error.is_empty
		end

	disconnect
			-- Close database connection.
		require
			connected: is_connected
		do
			-- Clear any pending result
			if attached last_result as res then
				res.clear
				last_result := Void
			end
			connection.disconnect
			last_error.wipe_out
		ensure
			not_connected: not is_connected
			no_result: last_result = Void
		end

feature -- Query Operations

	query (a_sql: STRING)
			-- Execute SELECT query and store result in `last_result'.
			-- Previous result is automatically cleared.
		require
			connected: is_connected
			sql_valid: a_sql /= Void and then not a_sql.is_empty
		local
			l_handle: POINTER
		do
			-- Clear previous result
			if attached last_result as res then
				res.clear
				last_result := Void
			end
			
			last_error.wipe_out
			l_handle := connection.execute (a_sql)
			
			if l_handle /= default_pointer and then connection.last_error.is_empty then
				create last_result.make (l_handle)
			else
				last_error := connection.last_error.twin
				if l_handle /= default_pointer then
					-- Clear failed result handle
					(create {PG_EXTERNALS}).c_pqclear (l_handle)
				end
			end
		ensure
			result_or_error: last_result /= Void or not last_error.is_empty
		end

	execute (a_sql: STRING)
			-- Execute INSERT/UPDATE/DELETE command.
			-- Sets `affected_rows' on success.
		require
			connected: is_connected
			sql_valid: a_sql /= Void and then not a_sql.is_empty
		local
			l_handle: POINTER
			l_ext: PG_EXTERNALS
		do
			last_error.wipe_out
			affected_rows := 0
			l_handle := connection.execute (a_sql)
			
			if l_handle /= default_pointer and then connection.last_error.is_empty then
				create l_ext
				affected_rows := l_ext.c_pqntuples (l_handle)
				l_ext.c_pqclear (l_handle)
			else
				last_error := connection.last_error.twin
				if l_handle /= default_pointer then
					(create {PG_EXTERNALS}).c_pqclear (l_handle)
				end
			end
		ensure
			success_or_error: affected_rows >= 0 or not last_error.is_empty
		end

feature {NONE} -- Implementation

	connection: PG_CONNECTION
			-- Internal connection handler

invariant
	connection_attached: connection /= Void
	last_error_attached: last_error /= Void

end

=== TEST GENERATION GUIDELINES ===

Generate comprehensive tests using Eiffel's Testing framework.
Test class MUST inherit from TEST_SET_BASE (from simple_testing library).
This provides enhanced assertion helpers beyond EQA_TEST_SET.

1. HAPPY PATH TESTS:
   - Test normal operation with valid inputs
   - Verify postconditions are satisfied
   - Check state changes after commands
   - Test typical use case scenarios

2. EDGE CASE TESTS (CRITICAL - STRESS THE CODE):
   - Boundary values (empty strings, zero, max values, negative numbers)
   - Precondition boundaries (just valid, just barely invalid)
   - State transitions at limits (empty to 1, full to overflow)
   - Unusual but valid inputs (Unicode, very long strings, special chars)
   - Negative/unexpected values where applicable (negative counts, etc.)
   - The goal is to BREAK the code and find bugs, then fix them!

3. CONTRACT VERIFICATION:
   - Tests that verify preconditions reject bad input
   - Tests that verify postconditions hold
   - Tests that verify invariants are maintained

4. TEST NAMING:
   - test_<feature>_<scenario> (test_add_contact_success)
   - test_<feature>_<edge_case> (test_add_contact_empty_name_rejected)

5. TEST STRUCTURE:
   feature -- Test: <Feature Group>
       test_feature_happy_path
       test_feature_edge_case_1
       test_feature_edge_case_2

=== OUTPUT FORMAT ===
Respond with a JSON object containing the test class:

```json
{
  "type": "test_class",
  "class_name": "TEST_LIBRARY_BOOK",
  "target_class": "LIBRARY_BOOK",
  "test_count": 8,
  "code": "note\n    description: \"Tests for LIBRARY_BOOK\"\nclass\n    TEST_LIBRARY_BOOK\ninherit\n    TEST_SET_BASE\n...\nend"
}
```

Output ONLY the JSON. No explanations before or after.

=== NEXT CLI COMMAND ===
Save this JSON response to a file and run:
  simple_codegen process --session <SESSION> --input <response_file.json>

Then compile and run the tests:
  simple_codegen compile --session <SESSION> --project <assembled_project>

If tests fail, refinement prompts will be auto-generated for the failing classes.
Generate tests for other classes:
  simple_codegen generate-tests --session <SESSION> --class <ANOTHER_CLASS>