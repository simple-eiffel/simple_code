{"name":"simple_postgres","state":"assembled","iteration":0,"prompt_count":8,"response_count":5,"classes":[{"name":"PG_EXTERNALS","description":"Low-level C external declarations for libpq","is_generated":true,"code":"note\n\tdescription: \"Low-level C external declarations for libpq PostgreSQL client library.\"\n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tPG_EXTERNALS\n\nfeature -- Connection\n\n\tc_pqconnectdb (a_conninfo: POINTER): POINTER\n\t\t\t-- Connect to database using connection string.\n\t\t\t-- Returns PGconn pointer or NULL on failure.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return PQconnectdb((const char*)$a_conninfo);\"\n\t\tend\n\n\tc_pqfinish (a_conn: POINTER)\n\t\t\t-- Close connection and free memory.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"PQfinish((PGconn*)$a_conn);\"\n\t\tend\n\n\tc_pqstatus (a_conn: POINTER): INTEGER\n\t\t\t-- Return connection status.\n\t\t\t-- 0 = CONNECTION_OK, 1 = CONNECTION_BAD\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return (EIF_INTEGER)PQstatus((PGconn*)$a_conn);\"\n\t\tend\n\n\tc_pqerrormessage (a_conn: POINTER): POINTER\n\t\t\t-- Return error message for connection.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return (char*)PQerrorMessage((PGconn*)$a_conn);\"\n\t\tend\n\nfeature -- Query Execution\n\n\tc_pqexec (a_conn: POINTER; a_query: POINTER): POINTER\n\t\t\t-- Execute SQL query.\n\t\t\t-- Returns PGresult pointer.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return PQexec((PGconn*)$a_conn, (const char*)$a_query);\"\n\t\tend\n\n\tc_pqresultstatus (a_result: POINTER): INTEGER\n\t\t\t-- Return result status.\n\t\t\t-- 0=EMPTY, 1=COMMAND_OK, 2=TUPLES_OK, etc.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return (EIF_INTEGER)PQresultStatus((PGresult*)$a_result);\"\n\t\tend\n\n\tc_pqresulterrormessage (a_result: POINTER): POINTER\n\t\t\t-- Return error message for result.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return (char*)PQresultErrorMessage((PGresult*)$a_result);\"\n\t\tend\n\nfeature -- Result Access\n\n\tc_pqntuples (a_result: POINTER): INTEGER\n\t\t\t-- Return number of rows in result.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return (EIF_INTEGER)PQntuples((PGresult*)$a_result);\"\n\t\tend\n\n\tc_pqnfields (a_result: POINTER): INTEGER\n\t\t\t-- Return number of columns in result.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return (EIF_INTEGER)PQnfields((PGresult*)$a_result);\"\n\t\tend\n\n\tc_pqgetvalue (a_result: POINTER; a_row, a_col: INTEGER): POINTER\n\t\t\t-- Return value at row/column as C string pointer.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return PQgetvalue((PGresult*)$a_result, (int)$a_row, (int)$a_col);\"\n\t\tend\n\n\tc_pqfname (a_result: POINTER; a_col: INTEGER): POINTER\n\t\t\t-- Return column name.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return PQfname((PGresult*)$a_result, (int)$a_col);\"\n\t\tend\n\n\tc_pqgetisnull (a_result: POINTER; a_row, a_col: INTEGER): INTEGER\n\t\t\t-- Return 1 if value is NULL, 0 otherwise.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"return (EIF_INTEGER)PQgetisnull((PGresult*)$a_result, (int)$a_row, (int)$a_col);\"\n\t\tend\n\nfeature -- Result Cleanup\n\n\tc_pqclear (a_result: POINTER)\n\t\t\t-- Free result memory.\n\t\texternal\n\t\t\t\"C inline use <libpq-fe.h>\"\n\t\talias\n\t\t\t\"PQclear((PGresult*)$a_result);\"\n\t\tend\n\nfeature -- Status Constants\n\n\tConnection_ok: INTEGER = 0\n\tConnection_bad: INTEGER = 1\n\n\tPgres_empty_query: INTEGER = 0\n\tPgres_command_ok: INTEGER = 1\n\tPgres_tuples_ok: INTEGER = 2\n\tPgres_bad_response: INTEGER = 5\n\tPgres_fatal_error: INTEGER = 7\n\nend"},{"name":"PG_CONNECTION","description":"PostgreSQL connection wrapper with lifecycle management","is_generated":true,"code":"note\n\tdescription: \"PostgreSQL connection wrapper with lifecycle management.\"\n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tPG_CONNECTION\n\ninherit\n\tPG_EXTERNALS\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Initialize disconnected connection.\n\t\tdo\n\t\t\tcreate last_error.make_empty\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\t\tno_error: last_error.is_empty\n\t\tend\n\nfeature -- Access\n\n\tlast_error: STRING\n\t\t\t-- Last error message from connection or query\n\nfeature -- Status Report\n\n\tis_connected: BOOLEAN\n\t\t\t-- Is connection currently open and valid?\n\t\tdo\n\t\t\tResult := connection_handle /= default_pointer and then\n\t\t\t          c_pqstatus (connection_handle) = Connection_ok\n\t\tend\n\nfeature -- Connection Operations\n\n\tconnect (a_connection_string: STRING)\n\t\t\t-- Connect to database using connection string.\n\t\t\t-- Format: \"host=localhost dbname=mydb user=postgres password=secret\"\n\t\trequire\n\t\t\tnot_connected: not is_connected\n\t\t\tconnection_string_valid: a_connection_string /= Void and then not a_connection_string.is_empty\n\t\tlocal\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\tcreate l_c_string.make (a_connection_string)\n\t\t\tconnection_handle := c_pqconnectdb (l_c_string.item)\n\t\t\t\n\t\t\tif connection_handle = default_pointer then\n\t\t\t\tlast_error := \"Failed to allocate connection\"\n\t\t\telseif c_pqstatus (connection_handle) /= Connection_ok then\n\t\t\t\tlast_error := pointer_to_string (c_pqerrormessage (connection_handle))\n\t\t\t\tc_pqfinish (connection_handle)\n\t\t\t\tconnection_handle := default_pointer\n\t\t\tend\n\t\tensure\n\t\t\tconnected_or_error: is_connected or not last_error.is_empty\n\t\tend\n\n\tdisconnect\n\t\t\t-- Close connection and release resources.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\tdo\n\t\t\tc_pqfinish (connection_handle)\n\t\t\tconnection_handle := default_pointer\n\t\t\tlast_error.wipe_out\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\tend\n\nfeature -- Query Execution\n\n\texecute (a_sql: STRING): POINTER\n\t\t\t-- Execute SQL and return result handle.\n\t\t\t-- Caller must call c_pqclear on result when done.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\t\tsql_valid: a_sql /= Void and then not a_sql.is_empty\n\t\tlocal\n\t\t\tl_c_string: C_STRING\n\t\t\tl_status: INTEGER\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\tcreate l_c_string.make (a_sql)\n\t\t\tResult := c_pqexec (connection_handle, l_c_string.item)\n\t\t\t\n\t\t\tif Result /= default_pointer then\n\t\t\t\tl_status := c_pqresultstatus (Result)\n\t\t\t\tif l_status /= Pgres_command_ok and l_status /= Pgres_tuples_ok then\n\t\t\t\t\tlast_error := pointer_to_string (c_pqresulterrormessage (Result))\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tlast_error := \"Query execution failed: null result\"\n\t\t\tend\n\t\tensure\n\t\t\tresult_or_error: Result /= default_pointer or not last_error.is_empty\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tconnection_handle: POINTER\n\t\t\t-- Internal libpq PGconn handle\n\n\tpointer_to_string (a_ptr: POINTER): STRING\n\t\t\t-- Convert C string pointer to Eiffel STRING.\n\t\tlocal\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tif a_ptr = default_pointer then\n\t\t\t\tResult := \"\"\n\t\t\telse\n\t\t\t\tcreate l_c_string.make_by_pointer (a_ptr)\n\t\t\t\tResult := l_c_string.string\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\ninvariant\n\tlast_error_attached: last_error /= Void\n\nend"},{"name":"PG_RESULT","description":"Query result set with row/column access","is_generated":true,"code":"note\n\tdescription: \"PostgreSQL query result set with row/column access.\"\n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tPG_RESULT\n\ninherit\n\tPG_EXTERNALS\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake (a_result_handle: POINTER)\n\t\t\t-- Initialize with result handle from query execution.\n\t\trequire\n\t\t\thandle_valid: a_result_handle /= default_pointer\n\t\tdo\n\t\t\tresult_handle := a_result_handle\n\t\t\trow_count := c_pqntuples (result_handle)\n\t\t\tcolumn_count := c_pqnfields (result_handle)\n\t\tensure\n\t\t\thandle_set: result_handle = a_result_handle\n\t\t\tis_valid: is_valid\n\t\tend\n\nfeature -- Access\n\n\trow_count: INTEGER\n\t\t\t-- Number of rows in result\n\n\tcolumn_count: INTEGER\n\t\t\t-- Number of columns in result\n\n\tvalue_at (a_row, a_col: INTEGER): detachable STRING\n\t\t\t-- Value at row/column position (0-indexed).\n\t\t\t-- Returns Void if value is NULL.\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\t\trow_valid: a_row >= 0 and a_row < row_count\n\t\t\tcol_valid: a_col >= 0 and a_col < column_count\n\t\tlocal\n\t\t\tl_ptr: POINTER\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tif c_pqgetisnull (result_handle, a_row, a_col) = 0 then\n\t\t\t\tl_ptr := c_pqgetvalue (result_handle, a_row, a_col)\n\t\t\t\tif l_ptr /= default_pointer then\n\t\t\t\t\tcreate l_c_string.make_by_pointer (l_ptr)\n\t\t\t\t\tResult := l_c_string.string\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\tcolumn_name (a_col: INTEGER): STRING\n\t\t\t-- Name of column at index (0-indexed).\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\t\tcol_valid: a_col >= 0 and a_col < column_count\n\t\tlocal\n\t\t\tl_ptr: POINTER\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tl_ptr := c_pqfname (result_handle, a_col)\n\t\t\tif l_ptr /= default_pointer then\n\t\t\t\tcreate l_c_string.make_by_pointer (l_ptr)\n\t\t\t\tResult := l_c_string.string\n\t\t\telse\n\t\t\t\tResult := \"\"\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\n\tis_null_at (a_row, a_col: INTEGER): BOOLEAN\n\t\t\t-- Is value at row/column NULL?\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\t\trow_valid: a_row >= 0 and a_row < row_count\n\t\t\tcol_valid: a_col >= 0 and a_col < column_count\n\t\tdo\n\t\t\tResult := c_pqgetisnull (result_handle, a_row, a_col) = 1\n\t\tend\n\nfeature -- Status Report\n\n\tis_valid: BOOLEAN\n\t\t\t-- Is result handle valid?\n\t\tdo\n\t\t\tResult := result_handle /= default_pointer\n\t\tend\n\n\tis_empty: BOOLEAN\n\t\t\t-- Does result have no rows?\n\t\tdo\n\t\t\tResult := row_count = 0\n\t\tend\n\nfeature -- Cleanup\n\n\tclear\n\t\t\t-- Free result memory. Result becomes invalid after this.\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\tdo\n\t\t\tc_pqclear (result_handle)\n\t\t\tresult_handle := default_pointer\n\t\t\trow_count := 0\n\t\t\tcolumn_count := 0\n\t\tensure\n\t\t\tnot_valid: not is_valid\n\t\t\tno_rows: row_count = 0\n\t\t\tno_cols: column_count = 0\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tresult_handle: POINTER\n\t\t\t-- Internal libpq PGresult handle\n\ninvariant\n\trow_count_non_negative: row_count >= 0\n\tcolumn_count_non_negative: column_count >= 0\n\nend"},{"name":"SIMPLE_POSTGRES","description":"Facade class - main API for simple_postgres library","is_generated":true,"code":"note\n\tdescription: \"[\n\t\tSimple PostgreSQL client library facade.\n\t\t\n\t\tProvides easy-to-use API for PostgreSQL database operations.\n\t\tWraps libpq with Eiffel idioms and Design by Contract.\n\t\t\n\t\tUsage:\n\t\t\tcreate db.make\n\t\t\tdb.connect (\"host=localhost dbname=test user=postgres\")\n\t\t\tif db.is_connected then\n\t\t\t\tdb.query (\"SELECT * FROM users\")\n\t\t\t\tif attached db.last_result as res then\n\t\t\t\t\t-- process results\n\t\t\t\t\tres.clear\n\t\t\t\tend\n\t\t\t\tdb.disconnect\n\t\t\tend\n\t]\" \n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tSIMPLE_POSTGRES\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Initialize disconnected database client.\n\t\tdo\n\t\t\tcreate connection.make\n\t\t\tcreate last_error.make_empty\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\t\tno_result: last_result = Void\n\t\tend\n\nfeature -- Access\n\n\tlast_result: detachable PG_RESULT\n\t\t\t-- Result from last query operation.\n\t\t\t-- Void if no query executed or query failed.\n\n\tlast_error: STRING\n\t\t\t-- Last error message (empty if no error)\n\n\taffected_rows: INTEGER\n\t\t\t-- Number of rows affected by last execute command\n\nfeature -- Status Report\n\n\tis_connected: BOOLEAN\n\t\t\t-- Is database connection open?\n\t\tdo\n\t\t\tResult := connection.is_connected\n\t\tend\n\nfeature -- Connection Operations\n\n\tconnect (a_connection_string: STRING)\n\t\t\t-- Connect to PostgreSQL database.\n\t\t\t-- Connection string format: \"host=localhost port=5432 dbname=mydb user=postgres password=secret\"\n\t\trequire\n\t\t\tnot_connected: not is_connected\n\t\t\tconnection_string_valid: a_connection_string /= Void and then not a_connection_string.is_empty\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\tconnection.connect (a_connection_string)\n\t\t\tif not connection.is_connected then\n\t\t\t\tlast_error := connection.last_error.twin\n\t\t\tend\n\t\tensure\n\t\t\tconnected_or_error: is_connected or not last_error.is_empty\n\t\tend\n\n\tdisconnect\n\t\t\t-- Close database connection.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\tdo\n\t\t\t-- Clear any pending result\n\t\t\tif attached last_result as res then\n\t\t\t\tres.clear\n\t\t\t\tlast_result := Void\n\t\t\tend\n\t\t\tconnection.disconnect\n\t\t\tlast_error.wipe_out\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\t\tno_result: last_result = Void\n\t\tend\n\nfeature -- Query Operations\n\n\tquery (a_sql: STRING)\n\t\t\t-- Execute SELECT query and store result in `last_result'.\n\t\t\t-- Previous result is automatically cleared.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\t\tsql_valid: a_sql /= Void and then not a_sql.is_empty\n\t\tlocal\n\t\t\tl_handle: POINTER\n\t\tdo\n\t\t\t-- Clear previous result\n\t\t\tif attached last_result as res then\n\t\t\t\tres.clear\n\t\t\t\tlast_result := Void\n\t\t\tend\n\t\t\t\n\t\t\tlast_error.wipe_out\n\t\t\tl_handle := connection.execute (a_sql)\n\t\t\t\n\t\t\tif l_handle /= default_pointer and then connection.last_error.is_empty then\n\t\t\t\tcreate last_result.make (l_handle)\n\t\t\telse\n\t\t\t\tlast_error := connection.last_error.twin\n\t\t\t\tif l_handle /= default_pointer then\n\t\t\t\t\t-- Clear failed result handle\n\t\t\t\t\t(create {PG_EXTERNALS}).c_pqclear (l_handle)\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\tresult_or_error: last_result /= Void or not last_error.is_empty\n\t\tend\n\n\texecute (a_sql: STRING)\n\t\t\t-- Execute INSERT/UPDATE/DELETE command.\n\t\t\t-- Sets `affected_rows' on success.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\t\tsql_valid: a_sql /= Void and then not a_sql.is_empty\n\t\tlocal\n\t\t\tl_handle: POINTER\n\t\t\tl_ext: PG_EXTERNALS\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\taffected_rows := 0\n\t\t\tl_handle := connection.execute (a_sql)\n\t\t\t\n\t\t\tif l_handle /= default_pointer and then connection.last_error.is_empty then\n\t\t\t\tcreate l_ext\n\t\t\t\taffected_rows := l_ext.c_pqntuples (l_handle)\n\t\t\t\tl_ext.c_pqclear (l_handle)\n\t\t\telse\n\t\t\t\tlast_error := connection.last_error.twin\n\t\t\t\tif l_handle /= default_pointer then\n\t\t\t\t\t(create {PG_EXTERNALS}).c_pqclear (l_handle)\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\tsuccess_or_error: affected_rows >= 0 or not last_error.is_empty\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tconnection: PG_CONNECTION\n\t\t\t-- Internal connection handler\n\ninvariant\n\tconnection_attached: connection /= Void\n\tlast_error_attached: last_error /= Void\n\nend"}],"external_dependencies":[{"name":"libpq","include_path":"$(POSTGRESQL_HOME)/include","library_path":"$(POSTGRESQL_HOME)/lib/libpq.lib"}],"current_step":7,"use_atomic_prompts":true,"workflow_todos":[{"task":"Generate system_spec.json","status":2,"step":1},{"task":"Generate PG_EXTERNALS","status":2,"step":2},{"task":"Generate PG_CONNECTION","status":2,"step":3},{"task":"Generate PG_RESULT","status":2,"step":4},{"task":"Generate SIMPLE_POSTGRES","status":2,"step":5},{"task":"Assemble project","status":2,"step":6},{"task":"Compile and verify","status":2,"step":7}]}