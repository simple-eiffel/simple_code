```json
{
  "type": "class_code",
  "class_name": "SIMPLE_POSTGRES",
  "code": "note\n\tdescription: \"[\n\t\tSimple PostgreSQL client library facade.\n\t\t\n\t\tProvides easy-to-use API for PostgreSQL database operations.\n\t\tWraps libpq with Eiffel idioms and Design by Contract.\n\t\t\n\t\tUsage:\n\t\t\tcreate db.make\n\t\t\tdb.connect (\"host=localhost dbname=test user=postgres\")\n\t\t\tif db.is_connected then\n\t\t\t\tdb.query (\"SELECT * FROM users\")\n\t\t\t\tif attached db.last_result as res then\n\t\t\t\t\t-- process results\n\t\t\t\t\tres.clear\n\t\t\t\tend\n\t\t\t\tdb.disconnect\n\t\t\tend\n\t]\" \n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tSIMPLE_POSTGRES\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Initialize disconnected database client.\n\t\tdo\n\t\t\tcreate connection.make\n\t\t\tcreate last_error.make_empty\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\t\tno_result: last_result = Void\n\t\tend\n\nfeature -- Access\n\n\tlast_result: detachable PG_RESULT\n\t\t\t-- Result from last query operation.\n\t\t\t-- Void if no query executed or query failed.\n\n\tlast_error: STRING\n\t\t\t-- Last error message (empty if no error)\n\n\taffected_rows: INTEGER\n\t\t\t-- Number of rows affected by last execute command\n\nfeature -- Status Report\n\n\tis_connected: BOOLEAN\n\t\t\t-- Is database connection open?\n\t\tdo\n\t\t\tResult := connection.is_connected\n\t\tend\n\nfeature -- Connection Operations\n\n\tconnect (a_connection_string: STRING)\n\t\t\t-- Connect to PostgreSQL database.\n\t\t\t-- Connection string format: \"host=localhost port=5432 dbname=mydb user=postgres password=secret\"\n\t\trequire\n\t\t\tnot_connected: not is_connected\n\t\t\tconnection_string_valid: a_connection_string /= Void and then not a_connection_string.is_empty\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\tconnection.connect (a_connection_string)\n\t\t\tif not connection.is_connected then\n\t\t\t\tlast_error := connection.last_error.twin\n\t\t\tend\n\t\tensure\n\t\t\tconnected_or_error: is_connected or not last_error.is_empty\n\t\tend\n\n\tdisconnect\n\t\t\t-- Close database connection.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\tdo\n\t\t\t-- Clear any pending result\n\t\t\tif attached last_result as res then\n\t\t\t\tres.clear\n\t\t\t\tlast_result := Void\n\t\t\tend\n\t\t\tconnection.disconnect\n\t\t\tlast_error.wipe_out\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\t\tno_result: last_result = Void\n\t\tend\n\nfeature -- Query Operations\n\n\tquery (a_sql: STRING)\n\t\t\t-- Execute SELECT query and store result in `last_result'.\n\t\t\t-- Previous result is automatically cleared.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\t\tsql_valid: a_sql /= Void and then not a_sql.is_empty\n\t\tlocal\n\t\t\tl_handle: POINTER\n\t\tdo\n\t\t\t-- Clear previous result\n\t\t\tif attached last_result as res then\n\t\t\t\tres.clear\n\t\t\t\tlast_result := Void\n\t\t\tend\n\t\t\t\n\t\t\tlast_error.wipe_out\n\t\t\tl_handle := connection.execute (a_sql)\n\t\t\t\n\t\t\tif l_handle /= default_pointer and then connection.last_error.is_empty then\n\t\t\t\tcreate last_result.make (l_handle)\n\t\t\telse\n\t\t\t\tlast_error := connection.last_error.twin\n\t\t\t\tif l_handle /= default_pointer then\n\t\t\t\t\t-- Clear failed result handle\n\t\t\t\t\t(create {PG_EXTERNALS}).c_pqclear (l_handle)\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\tresult_or_error: last_result /= Void or not last_error.is_empty\n\t\tend\n\n\texecute (a_sql: STRING)\n\t\t\t-- Execute INSERT/UPDATE/DELETE command.\n\t\t\t-- Sets `affected_rows' on success.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\t\tsql_valid: a_sql /= Void and then not a_sql.is_empty\n\t\tlocal\n\t\t\tl_handle: POINTER\n\t\t\tl_ext: PG_EXTERNALS\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\taffected_rows := 0\n\t\t\tl_handle := connection.execute (a_sql)\n\t\t\t\n\t\t\tif l_handle /= default_pointer and then connection.last_error.is_empty then\n\t\t\t\tcreate l_ext\n\t\t\t\taffected_rows := l_ext.c_pqntuples (l_handle)\n\t\t\t\tl_ext.c_pqclear (l_handle)\n\t\t\telse\n\t\t\t\tlast_error := connection.last_error.twin\n\t\t\t\tif l_handle /= default_pointer then\n\t\t\t\t\t(create {PG_EXTERNALS}).c_pqclear (l_handle)\n\t\t\t\tend\n\t\t\tend\n\t\tensure\n\t\t\tsuccess_or_error: affected_rows >= 0 or not last_error.is_empty\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tconnection: PG_CONNECTION\n\t\t\t-- Internal connection handler\n\ninvariant\n\tconnection_attached: connection /= Void\n\tlast_error_attached: last_error /= Void\n\nend",
  "notes": "Facade pattern - provides simple API hiding PG_CONNECTION and PG_RESULT complexity. Auto-clears previous results. Connection string follows libpq format."
}
```