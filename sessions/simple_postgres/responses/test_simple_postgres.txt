```json
{
  "type": "test_class",
  "class_name": "TEST_SIMPLE_POSTGRES",
  "target_class": "SIMPLE_POSTGRES",
  "test_count": 10,
  "code": "note\n\tdescription: \"[\n\t\tComprehensive tests for SIMPLE_POSTGRES facade class.\n\t\t\n\t\tRequires local PostgreSQL with:\n\t\t- Default postgres database accessible\n\t\t- User with trust authentication or password in connection string\n\t\t\n\t\tTests create/drop test tables, safe to run repeatedly.\n\t]\"\n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tTEST_SIMPLE_POSTGRES\n\ninherit\n\tTEST_SET_BASE\n\nfeature -- Test Configuration\n\n\ttest_connection_string: STRING = \"host=localhost port=5432 dbname=postgres\"\n\t\t\t-- Connection string for local PostgreSQL\n\nfeature -- Test: Creation\n\n\ttest_make_creates_disconnected_client\n\t\t\t-- Test that make creates a properly initialized client.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tassert (\"created\", l_db /= Void)\n\t\t\tassert (\"not_connected_initially\", not l_db.is_connected)\n\t\t\tassert (\"no_result_initially\", l_db.last_result = Void)\n\t\t\tassert (\"no_error_initially\", l_db.last_error.is_empty)\n\t\tend\n\nfeature -- Test: Connection (Happy Path)\n\n\ttest_connect_to_valid_database\n\t\t\t-- Test successful connection to local PostgreSQL.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\tassert (\"connected\", l_db.is_connected)\n\t\t\tassert (\"no_connect_error\", l_db.last_error.is_empty)\n\t\t\tl_db.disconnect\n\t\tend\n\n\ttest_disconnect_releases_connection\n\t\t\t-- Test that disconnect properly releases the connection.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\tl_db.disconnect\n\t\t\tassert (\"disconnected\", not l_db.is_connected)\n\t\tend\n\nfeature -- Test: Connection (Edge Cases)\n\n\ttest_connect_invalid_host_fails\n\t\t\t-- Test connection failure with invalid host.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (\"host=invalid_host_xyz port=5432 dbname=postgres connect_timeout=1\")\n\t\t\tassert (\"not_connected\", not l_db.is_connected)\n\t\t\tassert (\"has_error_message\", not l_db.last_error.is_empty)\n\t\tend\n\nfeature -- Test: Query Operations (Happy Path)\n\n\ttest_query_returns_result\n\t\t\t-- Test basic SELECT query returns result.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\tl_db.query (\"SELECT 1 AS num, 'hello' AS greeting\")\n\t\t\tassert (\"no_error\", l_db.last_error.is_empty)\n\t\t\tif attached l_db.last_result as res then\n\t\t\t\tassert (\"one_row\", res.row_count = 1)\n\t\t\t\tassert (\"two_columns\", res.column_count = 2)\n\t\t\t\tassert (\"value_num\", attached res.value_at (0, 0) as v and then v.same_string (\"1\"))\n\t\t\t\tassert (\"value_greeting\", attached res.value_at (0, 1) as v and then v.same_string (\"hello\"))\n\t\t\t\tres.clear\n\t\t\telse\n\t\t\t\tassert (\"result_attached\", False)\n\t\t\tend\n\t\t\tl_db.disconnect\n\t\tend\n\n\ttest_insert_and_select_roundtrip\n\t\t\t-- Test INSERT followed by SELECT retrieves same data.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\t-- Setup\n\t\t\tl_db.execute (\"DROP TABLE IF EXISTS sp_test\")\n\t\t\tl_db.execute (\"CREATE TABLE sp_test (id SERIAL PRIMARY KEY, name VARCHAR(100), value INTEGER)\")\n\t\t\t-- Insert\n\t\t\tl_db.execute (\"INSERT INTO sp_test (name, value) VALUES ('Alice', 100)\")\n\t\t\tl_db.execute (\"INSERT INTO sp_test (name, value) VALUES ('Bob', 200)\")\n\t\t\t-- Query\n\t\t\tl_db.query (\"SELECT name, value FROM sp_test ORDER BY name\")\n\t\t\tif attached l_db.last_result as res then\n\t\t\t\tassert (\"two_rows\", res.row_count = 2)\n\t\t\t\tassert (\"alice_name\", attached res.value_at (0, 0) as v and then v.same_string (\"Alice\"))\n\t\t\t\tassert (\"alice_value\", attached res.value_at (0, 1) as v and then v.same_string (\"100\"))\n\t\t\t\tassert (\"bob_name\", attached res.value_at (1, 0) as v and then v.same_string (\"Bob\"))\n\t\t\t\tres.clear\n\t\t\tend\n\t\t\t-- Cleanup\n\t\t\tl_db.execute (\"DROP TABLE sp_test\")\n\t\t\tl_db.disconnect\n\t\tend\n\nfeature -- Test: Query Operations (Edge Cases)\n\n\ttest_query_invalid_sql_sets_error\n\t\t\t-- Test that invalid SQL produces error, not result.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\tl_db.query (\"SELECT * FROM nonexistent_table_xyz_123\")\n\t\t\tassert (\"has_error\", not l_db.last_error.is_empty)\n\t\t\tassert (\"no_result\", l_db.last_result = Void)\n\t\t\tl_db.disconnect\n\t\tend\n\n\ttest_query_empty_result\n\t\t\t-- Test query returning zero rows.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\tl_db.execute (\"DROP TABLE IF EXISTS sp_test\")\n\t\t\tl_db.execute (\"CREATE TABLE sp_test (id SERIAL PRIMARY KEY)\")\n\t\t\tl_db.query (\"SELECT * FROM sp_test\")\n\t\t\tif attached l_db.last_result as res then\n\t\t\t\tassert (\"zero_rows\", res.row_count = 0)\n\t\t\t\tassert (\"is_empty\", res.is_empty)\n\t\t\t\tres.clear\n\t\t\tend\n\t\t\tl_db.execute (\"DROP TABLE sp_test\")\n\t\t\tl_db.disconnect\n\t\tend\n\n\ttest_query_null_value_handling\n\t\t\t-- Test that NULL values are properly detected.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\tl_db.execute (\"DROP TABLE IF EXISTS sp_test\")\n\t\t\tl_db.execute (\"CREATE TABLE sp_test (id SERIAL PRIMARY KEY, nullable_col VARCHAR(100))\")\n\t\t\tl_db.execute (\"INSERT INTO sp_test (nullable_col) VALUES (NULL)\")\n\t\t\tl_db.query (\"SELECT nullable_col FROM sp_test\")\n\t\t\tif attached l_db.last_result as res then\n\t\t\t\tassert (\"is_null\", res.is_null_at (0, 0))\n\t\t\t\tassert (\"value_is_void\", res.value_at (0, 0) = Void)\n\t\t\t\tres.clear\n\t\t\tend\n\t\t\tl_db.execute (\"DROP TABLE sp_test\")\n\t\t\tl_db.disconnect\n\t\tend\n\n\ttest_multiple_sequential_queries\n\t\t\t-- Test running many queries clears previous results.\n\t\tlocal\n\t\t\tl_db: SIMPLE_POSTGRES\n\t\t\ti: INTEGER\n\t\tdo\n\t\t\tcreate l_db.make\n\t\t\tl_db.connect (test_connection_string)\n\t\t\tfrom i := 1 until i > 5 loop\n\t\t\t\tl_db.query (\"SELECT \" + i.out + \" AS n\")\n\t\t\t\tif attached l_db.last_result as res then\n\t\t\t\t\tassert (\"query_\" + i.out, attached res.value_at (0, 0) as v and then v.same_string (i.out))\n\t\t\t\t\t-- Don't clear - let next query auto-clear\n\t\t\t\tend\n\t\t\t\ti := i + 1\n\t\t\tend\n\t\t\tl_db.disconnect\n\t\tend\n\nend"
}
```
