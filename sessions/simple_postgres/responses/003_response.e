```json
{
  "type": "class_code",
  "class_name": "PG_CONNECTION",
  "code": "note\n\tdescription: \"PostgreSQL connection wrapper with lifecycle management.\"\n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tPG_CONNECTION\n\ninherit\n\tPG_EXTERNALS\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Initialize disconnected connection.\n\t\tdo\n\t\t\tcreate last_error.make_empty\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\t\tno_error: last_error.is_empty\n\t\tend\n\nfeature -- Access\n\n\tlast_error: STRING\n\t\t\t-- Last error message from connection or query\n\nfeature -- Status Report\n\n\tis_connected: BOOLEAN\n\t\t\t-- Is connection currently open and valid?\n\t\tdo\n\t\t\tResult := connection_handle /= default_pointer and then\n\t\t\t          c_pqstatus (connection_handle) = Connection_ok\n\t\tend\n\nfeature -- Connection Operations\n\n\tconnect (a_connection_string: STRING)\n\t\t\t-- Connect to database using connection string.\n\t\t\t-- Format: \"host=localhost dbname=mydb user=postgres password=secret\"\n\t\trequire\n\t\t\tnot_connected: not is_connected\n\t\t\tconnection_string_valid: a_connection_string /= Void and then not a_connection_string.is_empty\n\t\tlocal\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\tcreate l_c_string.make (a_connection_string)\n\t\t\tconnection_handle := c_pqconnectdb (l_c_string.item)\n\t\t\t\n\t\t\tif connection_handle = default_pointer then\n\t\t\t\tlast_error := \"Failed to allocate connection\"\n\t\t\telseif c_pqstatus (connection_handle) /= Connection_ok then\n\t\t\t\tlast_error := pointer_to_string (c_pqerrormessage (connection_handle))\n\t\t\t\tc_pqfinish (connection_handle)\n\t\t\t\tconnection_handle := default_pointer\n\t\t\tend\n\t\tensure\n\t\t\tconnected_or_error: is_connected or not last_error.is_empty\n\t\tend\n\n\tdisconnect\n\t\t\t-- Close connection and release resources.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\tdo\n\t\t\tc_pqfinish (connection_handle)\n\t\t\tconnection_handle := default_pointer\n\t\t\tlast_error.wipe_out\n\t\tensure\n\t\t\tnot_connected: not is_connected\n\t\tend\n\nfeature -- Query Execution\n\n\texecute (a_sql: STRING): POINTER\n\t\t\t-- Execute SQL and return result handle.\n\t\t\t-- Caller must call c_pqclear on result when done.\n\t\trequire\n\t\t\tconnected: is_connected\n\t\t\tsql_valid: a_sql /= Void and then not a_sql.is_empty\n\t\tlocal\n\t\t\tl_c_string: C_STRING\n\t\t\tl_status: INTEGER\n\t\tdo\n\t\t\tlast_error.wipe_out\n\t\t\tcreate l_c_string.make (a_sql)\n\t\t\tResult := c_pqexec (connection_handle, l_c_string.item)\n\t\t\t\n\t\t\tif Result /= default_pointer then\n\t\t\t\tl_status := c_pqresultstatus (Result)\n\t\t\t\tif l_status /= Pgres_command_ok and l_status /= Pgres_tuples_ok then\n\t\t\t\t\tlast_error := pointer_to_string (c_pqresulterrormessage (Result))\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tlast_error := \"Query execution failed: null result\"\n\t\t\tend\n\t\tensure\n\t\t\tresult_or_error: Result /= default_pointer or not last_error.is_empty\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tconnection_handle: POINTER\n\t\t\t-- Internal libpq PGconn handle\n\n\tpointer_to_string (a_ptr: POINTER): STRING\n\t\t\t-- Convert C string pointer to Eiffel STRING.\n\t\tlocal\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tif a_ptr = default_pointer then\n\t\t\t\tResult := \"\"\n\t\t\telse\n\t\t\t\tcreate l_c_string.make_by_pointer (a_ptr)\n\t\t\t\tResult := l_c_string.string\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\ninvariant\n\tlast_error_attached: last_error /= Void\n\nend",
  "notes": "Inherits from PG_EXTERNALS for C externals. Uses C_STRING for string conversion. Connection handle managed internally. Last error captured on failures."
}
```