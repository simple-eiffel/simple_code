```json
{
  "type": "class_code",
  "class_name": "PG_RESULT",
  "code": "note\n\tdescription: \"PostgreSQL query result set with row/column access.\"\n\tauthor: \"Larry Rix\"\n\tdate: \"$Date$\"\n\trevision: \"$Revision$\"\n\nclass\n\tPG_RESULT\n\ninherit\n\tPG_EXTERNALS\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake (a_result_handle: POINTER)\n\t\t\t-- Initialize with result handle from query execution.\n\t\trequire\n\t\t\thandle_valid: a_result_handle /= default_pointer\n\t\tdo\n\t\t\tresult_handle := a_result_handle\n\t\t\trow_count := c_pqntuples (result_handle)\n\t\t\tcolumn_count := c_pqnfields (result_handle)\n\t\tensure\n\t\t\thandle_set: result_handle = a_result_handle\n\t\t\tis_valid: is_valid\n\t\tend\n\nfeature -- Access\n\n\trow_count: INTEGER\n\t\t\t-- Number of rows in result\n\n\tcolumn_count: INTEGER\n\t\t\t-- Number of columns in result\n\n\tvalue_at (a_row, a_col: INTEGER): detachable STRING\n\t\t\t-- Value at row/column position (0-indexed).\n\t\t\t-- Returns Void if value is NULL.\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\t\trow_valid: a_row >= 0 and a_row < row_count\n\t\t\tcol_valid: a_col >= 0 and a_col < column_count\n\t\tlocal\n\t\t\tl_ptr: POINTER\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tif c_pqgetisnull (result_handle, a_row, a_col) = 0 then\n\t\t\t\tl_ptr := c_pqgetvalue (result_handle, a_row, a_col)\n\t\t\t\tif l_ptr /= default_pointer then\n\t\t\t\t\tcreate l_c_string.make_by_pointer (l_ptr)\n\t\t\t\t\tResult := l_c_string.string\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\tcolumn_name (a_col: INTEGER): STRING\n\t\t\t-- Name of column at index (0-indexed).\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\t\tcol_valid: a_col >= 0 and a_col < column_count\n\t\tlocal\n\t\t\tl_ptr: POINTER\n\t\t\tl_c_string: C_STRING\n\t\tdo\n\t\t\tl_ptr := c_pqfname (result_handle, a_col)\n\t\t\tif l_ptr /= default_pointer then\n\t\t\t\tcreate l_c_string.make_by_pointer (l_ptr)\n\t\t\t\tResult := l_c_string.string\n\t\t\telse\n\t\t\t\tResult := \"\"\n\t\t\tend\n\t\tensure\n\t\t\tresult_attached: Result /= Void\n\t\tend\n\n\tis_null_at (a_row, a_col: INTEGER): BOOLEAN\n\t\t\t-- Is value at row/column NULL?\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\t\trow_valid: a_row >= 0 and a_row < row_count\n\t\t\tcol_valid: a_col >= 0 and a_col < column_count\n\t\tdo\n\t\t\tResult := c_pqgetisnull (result_handle, a_row, a_col) = 1\n\t\tend\n\nfeature -- Status Report\n\n\tis_valid: BOOLEAN\n\t\t\t-- Is result handle valid?\n\t\tdo\n\t\t\tResult := result_handle /= default_pointer\n\t\tend\n\n\tis_empty: BOOLEAN\n\t\t\t-- Does result have no rows?\n\t\tdo\n\t\t\tResult := row_count = 0\n\t\tend\n\nfeature -- Cleanup\n\n\tclear\n\t\t\t-- Free result memory. Result becomes invalid after this.\n\t\trequire\n\t\t\tis_valid: is_valid\n\t\tdo\n\t\t\tc_pqclear (result_handle)\n\t\t\tresult_handle := default_pointer\n\t\t\trow_count := 0\n\t\t\tcolumn_count := 0\n\t\tensure\n\t\t\tnot_valid: not is_valid\n\t\t\tno_rows: row_count = 0\n\t\t\tno_cols: column_count = 0\n\t\tend\n\nfeature {NONE} -- Implementation\n\n\tresult_handle: POINTER\n\t\t\t-- Internal libpq PGresult handle\n\ninvariant\n\trow_count_non_negative: row_count >= 0\n\tcolumn_count_non_negative: column_count >= 0\n\nend",
  "notes": "Wraps PGresult handle. Provides row/column access with NULL handling. 0-indexed like libpq. Must call clear() when done to free memory."
}
```