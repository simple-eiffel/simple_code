note
	description: "[
		Generates Eiffel class skeleton: signatures + contracts + notes (no implementations).

		The skeleton contains everything needed to SPECIFY the class:
		- Note clause (class description)
		- Inheritance structure
		- Creation procedures (signatures only)
		- Feature signatures with require/ensure contracts
		- Feature note clauses describing intent
		- Class invariant

		Implementations (do...end blocks) are NOT generated here.
		Those are generated by SCG_FEATURE_GEN using this skeleton as specification.

		Usage:
			create skeleton.make (system_spec, class_spec, ai_client)
			if skeleton.is_generated then
				-- skeleton.class_text has signatures + contracts
				-- skeleton.feature_specs has specs for each feature
			end
	]"
	author: "Larry Rix"
	date: "$Date$"
	revision: "$Revision$"

class
	SCG_CLASS_SKELETON

create
	make

feature {NONE} -- Initialization

	make (a_system_spec, a_class_spec: STRING_32; a_ai: AI_CLIENT)
			-- Generate class skeleton from specifications.
		require
			system_spec_not_empty: not a_system_spec.is_empty
			class_spec_not_empty: not a_class_spec.is_empty
			ai_not_void: a_ai /= Void
		do
			system_spec := a_system_spec
			class_spec := a_class_spec
			ai_client := a_ai
			create class_text.make_empty
			create feature_specs.make (10)
			create last_error.make_empty
			create generation_log.make (10)

			generate_skeleton
		ensure
			specs_stored: system_spec = a_system_spec and class_spec = a_class_spec
		end

feature -- Status

	is_generated: BOOLEAN
			-- Was skeleton successfully generated?

	has_error: BOOLEAN
			-- Did generation fail?
		do
			Result := not last_error.is_empty
		end

feature -- Access

	system_spec: STRING_32
			-- System specification

	class_spec: STRING_32
			-- Class specification

	ai_client: AI_CLIENT
			-- AI client for generation

	class_text: STRING_32
			-- Generated skeleton text (signatures + contracts, no implementations)

	class_name: STRING_32
			-- Extracted class name
		attribute
			create Result.make_empty
		end

	feature_specs: ARRAYED_LIST [SCG_FEATURE_SPEC]
			-- Specifications for each feature (extracted from skeleton)

	last_error: STRING_32
			-- Error message if generation failed

	generation_log: ARRAYED_LIST [STRING_32]
			-- Log of generation actions

feature {NONE} -- Generation

	generate_skeleton
			-- Generate the class skeleton using AI.
		local
			l_prompt: STRING_32
			l_response: AI_RESPONSE
		do
			log_action ("Building skeleton generation prompt")
			l_prompt := build_skeleton_prompt

			log_action ("Sending to AI (" + l_prompt.count.out + " chars)")
			l_response := ai_client.ask_with_system (skeleton_system_prompt, l_prompt)

			if l_response.is_success then
				class_text := extract_eiffel_code (l_response.text)
				if not class_text.is_empty then
					log_action ("Skeleton generated (" + class_text.count.out + " chars)")
					extract_class_name
					extract_feature_specs
					is_generated := True
				else
					last_error := "No Eiffel code in AI response"
					log_action ("ERROR: " + last_error)
				end
			else
				if attached l_response.error_message as err then
					last_error := err.twin
				else
					last_error := "Unknown AI error"
				end
				log_action ("ERROR: " + last_error)
			end
		end

	build_skeleton_prompt: STRING_32
			-- Build prompt for skeleton generation.
		do
			create Result.make (3000)
			Result.append ("Generate an Eiffel class SKELETON (signatures and contracts only, NO implementations).%N%N")

			Result.append ("=== SYSTEM CONTEXT ===%N")
			Result.append (system_spec)
			Result.append ("%N%N")

			Result.append ("=== CLASS SPECIFICATION ===%N")
			Result.append (class_spec)
			Result.append ("%N%N")

			Result.append ("=== OUTPUT FORMAT ===%N")
			Result.append ("Generate a class with:%N")
			Result.append ("1. Comprehensive note clause (description, author, date)%N")
			Result.append ("2. Inheritance (if needed)%N")
			Result.append ("3. Creation procedure signatures with contracts%N")
			Result.append ("4. Feature signatures with:%N")
			Result.append ("   - Feature note clause describing intent%N")
			Result.append ("   - Full signature (name, arguments, return type)%N")
			Result.append ("   - require clause (preconditions)%N")
			Result.append ("   - ensure clause (postconditions)%N")
			Result.append ("   - PLACEHOLDER body: do check False then end end%N")
			Result.append ("5. Class invariant%N%N")

			Result.append ("=== CRITICAL ===%N")
			Result.append ("- Every feature body must be: do check False then end end%N")
			Result.append ("- This is a SKELETON - implementations come later%N")
			Result.append ("- Contracts define WHAT each feature does%N")
			Result.append ("- Feature notes describe WHY and HOW (conceptually)%N%N")

			Result.append ("Output ONLY the Eiffel class in ```eiffel ... ``` markers.%N")
		end

	skeleton_system_prompt: STRING_32
			-- System prompt for skeleton generation.
		once
			Result := {STRING_32} "[
Expert Eiffel architect. Design by Contract specialist.
Generate class SKELETONS: signatures + contracts + notes.
All feature bodies: do check False then end end
Contracts specify behavior. Notes explain intent.
STRING_32 concat: use {STRING_32} "text" + var (NOT "text" + var).
Output: ```eiffel skeleton only, no explanation.
]"
		end

feature {NONE} -- Extraction

	extract_class_name
			-- Extract class name from skeleton.
		local
			l_start, l_end: INTEGER
			l_line: STRING_32
		do
			l_start := class_text.substring_index ("class", 1)
			if l_start > 0 then
				l_start := l_start + 5 -- Skip "class"
				l_end := class_text.index_of ('%N', l_start)
				if l_end > l_start then
					l_line := class_text.substring (l_start, l_end - 1)
					l_line.left_adjust
					l_line.right_adjust
					-- Handle generic parameters
					l_end := l_line.index_of (' ', 1)
					if l_end > 0 then
						class_name := l_line.substring (1, l_end - 1)
					else
						l_end := l_line.index_of ('[', 1)
						if l_end > 0 then
							class_name := l_line.substring (1, l_end - 1)
						else
							class_name := l_line.twin
						end
					end
					log_action ("Extracted class name: " + class_name)
				end
			end
		end

	extract_feature_specs
			-- Extract feature specifications from skeleton.
		local
			l_lines: LIST [STRING_32]
			l_in_feature: BOOLEAN
			l_current_name: STRING_32
			l_current_signature: STRING_32
			l_current_require: STRING_32
			l_current_ensure: STRING_32
			l_current_note: STRING_32
			l_line: STRING_32
			l_section: INTEGER -- 0=none, 1=note, 2=require, 3=ensure
			l_spec: SCG_FEATURE_SPEC
		do
			l_lines := class_text.split ('%N')
			create l_current_name.make_empty
			create l_current_signature.make_empty
			create l_current_require.make_empty
			create l_current_ensure.make_empty
			create l_current_note.make_empty

			across l_lines as ic loop
				l_line := ic.twin
				l_line.left_adjust

				if l_line.starts_with ("feature") then
					-- Save previous feature if any
					if not l_current_name.is_empty then
						create l_spec.make (l_current_name, l_current_signature, l_current_require, l_current_ensure, l_current_note)
						feature_specs.extend (l_spec)
					end
					l_in_feature := True
					l_current_name.wipe_out
					l_current_signature.wipe_out
					l_current_require.wipe_out
					l_current_ensure.wipe_out
					l_current_note.wipe_out
					l_section := 0

				elseif l_in_feature then
					if is_feature_signature (l_line) then
						-- Save previous feature if any
						if not l_current_name.is_empty then
							create l_spec.make (l_current_name, l_current_signature, l_current_require, l_current_ensure, l_current_note)
							feature_specs.extend (l_spec)
						end
						l_current_name := extract_feature_name (l_line)
						l_current_signature := l_line.twin
						l_current_require.wipe_out
						l_current_ensure.wipe_out
						l_current_note.wipe_out
						l_section := 0

					elseif l_line.starts_with ("note") then
						l_section := 1
					elseif l_line.starts_with ("require") then
						l_section := 2
					elseif l_line.starts_with ("ensure") then
						l_section := 3
					elseif l_line.starts_with ("do") or l_line.starts_with ("local") then
						l_section := 0
					elseif l_line.starts_with ("end") then
						l_section := 0
					elseif l_line.starts_with ("invariant") then
						-- Save last feature
						if not l_current_name.is_empty then
							create l_spec.make (l_current_name, l_current_signature, l_current_require, l_current_ensure, l_current_note)
							feature_specs.extend (l_spec)
						end
						l_in_feature := False
					else
						-- Accumulate based on section
						inspect l_section
						when 1 then
							l_current_note.append (l_line)
							l_current_note.append ("%N")
						when 2 then
							l_current_require.append (l_line)
							l_current_require.append ("%N")
						when 3 then
							l_current_ensure.append (l_line)
							l_current_ensure.append ("%N")
						else
							-- Ignore
						end
					end
				end
			end

			-- Save last feature if any
			if not l_current_name.is_empty then
				create l_spec.make (l_current_name, l_current_signature, l_current_require, l_current_ensure, l_current_note)
				feature_specs.extend (l_spec)
			end

			log_action ("Extracted " + feature_specs.count.out + " feature specifications")
		end

	is_feature_signature (a_line: STRING_32): BOOLEAN
			-- Is this line a feature signature?
		local
			l_trimmed: STRING_32
		do
			l_trimmed := a_line.twin
			l_trimmed.left_adjust
			-- Feature signature: starts with identifier, may have arguments/return type
			-- Not: note, require, ensure, do, local, end, invariant, feature, class, inherit, create
			if not l_trimmed.is_empty then
				Result := l_trimmed.item (1).is_alpha
					and not l_trimmed.starts_with ("note")
					and not l_trimmed.starts_with ("require")
					and not l_trimmed.starts_with ("ensure")
					and not l_trimmed.starts_with ("do")
					and not l_trimmed.starts_with ("local")
					and not l_trimmed.starts_with ("end")
					and not l_trimmed.starts_with ("invariant")
					and not l_trimmed.starts_with ("feature")
					and not l_trimmed.starts_with ("class")
					and not l_trimmed.starts_with ("inherit")
					and not l_trimmed.starts_with ("create")
					and not l_trimmed.starts_with ("--")
					and (l_trimmed.has (':') or l_trimmed.has ('(') or l_trimmed.ends_with ("end"))
			end
		end

	extract_feature_name (a_signature: STRING_32): STRING_32
			-- Extract feature name from signature line.
		local
			l_end: INTEGER
		do
			create Result.make_empty
			l_end := a_signature.index_of (':', 1)
			if l_end = 0 then
				l_end := a_signature.index_of ('(', 1)
			end
			if l_end = 0 then
				l_end := a_signature.index_of (' ', 1)
			end
			if l_end > 1 then
				Result := a_signature.substring (1, l_end - 1)
				Result.left_adjust
				Result.right_adjust
			end
		end

feature {NONE} -- Helpers

	extract_eiffel_code (a_response: STRING_32): STRING_32
			-- Extract Eiffel code from AI response.
		local
			l_start, l_end: INTEGER
		do
			create Result.make_empty
			l_start := a_response.substring_index ("```eiffel", 1)
			if l_start > 0 then
				l_start := a_response.index_of ('%N', l_start) + 1
				l_end := a_response.substring_index ("```", l_start)
				if l_end > l_start then
					Result := a_response.substring (l_start, l_end - 1)
				elseif l_start <= a_response.count then
					Result := a_response.substring (l_start, a_response.count)
				end
			else
				l_start := a_response.substring_index ("```", 1)
				if l_start > 0 then
					l_start := a_response.index_of ('%N', l_start) + 1
					l_end := a_response.substring_index ("```", l_start)
					if l_end > l_start then
						Result := a_response.substring (l_start, l_end - 1)
					end
				else
					Result := a_response.twin
				end
			end
			Result.left_adjust
			Result.right_adjust
		end

	log_action (a_message: STRING_32)
			-- Log an action.
		do
			generation_log.extend (a_message)
		end

invariant
	system_spec_exists: system_spec /= Void
	class_spec_exists: class_spec /= Void
	class_text_exists: class_text /= Void
	feature_specs_exists: feature_specs /= Void
	last_error_exists: last_error /= Void
	generated_has_text: is_generated implies not class_text.is_empty

end
